<!DOCTYPE html>
<html>
<head>
    <title>NeoNodule Project Map - Version 1.4 - Published 2024-11-30</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
 <!-- This style ensures that the neonodmap extends over the whole window -->
    <style>
    
 		* {cursor: url(/assets/arrow.cur), default; }
 		img:hover {
    			cursor: pointer;
		}
 		   
      	html, body, #map {
        width: 100%;
        height: 100%;
        margin: 0;
      	}
      	.star{
  		font-size: 1.5em;
		}
		.input {
		  position: absolute;
		  top: 0;
		  right: 0;
		  margin-top: 8px;
		}
    </style>
    
    <!-- SlideShow Style -->		    
    <style>
		* {box-sizing: border-box}

		body {font-family: Verdana, sans-serif; margin:0}

		.mySlides {display: none}

		img {vertical-align: middle;}
		
		/* Slideshow container */
		.slideshow-container {
		  max-width: 1000px;
		  position: relative;
		  margin: auto;
		}
		
		/* Next & previous buttons */
		.prev, .next {
		  cursor: pointer;
		  position: absolute;
		  top: 50%;
		  width: auto;
		  padding: 16px;
		  margin-top: -22px;
		  color: white;
		  font-weight: bold;
		  font-size: 18px;
		  transition: 0.6s ease;
		  border-radius: 0 3px 3px 0;
		  user-select: none;
		}
		
		/* Position the "next button" to the right */
		.next {
		  right: 0;
		  border-radius: 3px 0 0 3px;
		}
		
		/* On hover, add a black background color with a little bit see-through */
		.prev:hover, .next:hover {
		  background-color: rgba(0,0,0,0.8);
		}
		
		/* Caption text */
		.text {
		  color: #f2f2f2;
		  font-size: 15px;
		  padding: 8px 12px;
		  position: absolute;
		  bottom: 8px;
		  width: 100%;
		  text-align: center;
		}
		
		/* Number text (1/3 etc) */
		.numbertext {
		  color: #f2f2f2;
		  font-size: 12px;
		  padding: 8px 12px;
		  position: absolute;
		  top: 0;
		}
		
		/* The dots/bullets/indicators */
		.dot {
		  cursor: pointer;
		  height: 15px;
		  width: 15px;
		  margin: 0 2px;
		  background-color: #bbb;
		  border-radius: 50%;
		  display: inline-block;
		  transition: background-color 0.6s ease;
		}
		
		.active, .dot:hover {
		  background-color: #717171;
		}
		
		/* Fading animation */
		.fade {
		  -webkit-animation-name: fade;
		  -webkit-animation-duration: 1.5s;
		  animation-name: fade;
		  animation-duration: 1.5s;
		}
		
		@-webkit-keyframes fade {
		  from {opacity: .4} 
		  to {opacity: 1}
		}
		
		@keyframes fade {
		  from {opacity: .4} 
		  to {opacity: 1}
		}
		
		/* On smaller screens, decrease text size */
		@media only screen and (max-width: 300px) {
		  .prev, .next,.text {font-size: 11px}
		}
	</style>    
    <!-- Leaflet Sidebar Style -->		
    <style type="text/css">		
		.leaflet-sidebar {
		  position: absolute;
		  height: 100%;
		  -webkit-box-sizing: border-box;
		  -moz-box-sizing: border-box;
		  box-sizing: border-box;
		  padding: 10px;
		  z-index: 2000; }
		  .leaflet-sidebar.left {
		    left: -500px;
		    transition: left 0.5s, width 0.5s;
		    padding-right: 0; }
		    .leaflet-sidebar.left.visible {
		      left: 0; }
		  .leaflet-sidebar.right {
		    right: -500px;
		    transition: right 0.5s, width 0.5s;
		    padding-left: 0; }
		    .leaflet-sidebar.right.visible {
		      right: 0; }
		  .leaflet-sidebar > .leaflet-control {
		    height: 100%;
		    width: 100%;
		    overflow: auto;
		    -webkit-overflow-scrolling: touch;
		    -webkit-box-sizing: border-box;
		    -moz-box-sizing: border-box;
		    box-sizing: border-box;
		    padding: 8px 24px;
		    font-size: 1.1em;
		    background: white;
		    box-shadow: 0 1px 7px rgba(0, 0, 0, 0.65);
		    -webkit-border-radius: 4px;
		    border-radius: 4px; }
		    .leaflet-touch .leaflet-sidebar > .leaflet-control {
		      box-shadow: none;
		      border: 2px solid rgba(0, 0, 0, 0.2);
		      background-clip: padding-box; }
		  @media (max-width: 767px) {
		    .leaflet-sidebar {
		      width: 100%;
		      padding: 0; }
		      .leaflet-sidebar.left.visible ~ .leaflet-left {
		        left: 100%; }
		      .leaflet-sidebar.right.visible ~ .leaflet-right {
		        right: 100%; }
		      .leaflet-sidebar.left {
		        left: -100%; }
		        .leaflet-sidebar.left.visible {
		          left: 0; }
		      .leaflet-sidebar.right {
		        right: -100%; }
		        .leaflet-sidebar.right.visible {
		          right: 0; }
		      .leaflet-sidebar > .leaflet-control {
		        box-shadow: none;
		        -webkit-border-radius: 0;
		        border-radius: 0; }
		        .leaflet-touch .leaflet-sidebar > .leaflet-control {
		          border: 0; } }
		  @media (min-width: 768px) and (max-width: 991px) {
		    .leaflet-sidebar {
		      width: 305px; }
		      .leaflet-sidebar.left.visible ~ .leaflet-left {
		        left: 305px; }
		      .leaflet-sidebar.right.visible ~ .leaflet-right {
		        right: 305px; } }
		  @media (min-width: 992px) and (max-width: 1199px) {
		    .leaflet-sidebar {
		      width: 390px; }
		      .leaflet-sidebar.left.visible ~ .leaflet-left {
		        left: 390px; }
		      .leaflet-sidebar.right.visible ~ .leaflet-right {
		        right: 390px; } }
		  @media (min-width: 1200px) {
		    .leaflet-sidebar {
		      width: 460px; }
		      .leaflet-sidebar.left.visible ~ .leaflet-left {
		        left: 460px; }
		      .leaflet-sidebar.right.visible ~ .leaflet-right {
		        right: 460px; } }
		  .leaflet-sidebar .close {
		    position: absolute;
		    right: 20px;
		    top: 20px;
		    width: 31px;
		    height: 31px;
		    color: #333;
		    font-size: 25px;
		    line-height: 1em;
		    text-align: center;
		    background: white;
		    -webkit-border-radius: 16px;
		    border-radius: 16px;
		    cursor: pointer;
		    z-index: 8; }
		
		.leaflet-left {
		  transition: left 0.5s; }
		
		.leaflet-right {
		  transition: right 0.5s; }

		.leaflet-popup-content {
		    max-width: 700px;
		    height: 300px;
		    overflow-y: scroll;
		}
		
    </style>

    <script type="text/javascript">
	    function HashTable(obj)
	    {
	        this.length = 0;
	        this.items = {};
	        for (var p in obj) {
	            if (obj.hasOwnProperty(p)) {
	                this.items[p] = obj[p];
	                this.length++;
	            }
	        }
	
	        this.setItem = function(key, value)
	        {
	            var previous = undefined;
	            if (this.hasItem(key)) {
	                previous = this.items[key];
	            }
	            else {
	                this.length++;
	            }
	            this.items[key] = value;
	            return previous;
	        }
	
	        this.getItem = function(key) {
	            return this.hasItem(key) ? this.items[key] : undefined;
	        }
	
	        this.hasItem = function(key)
	        {
	            return this.items.hasOwnProperty(key);
	        }
	       
	        this.removeItem = function(key)
	        {
	            if (this.hasItem(key)) {
	                previous = this.items[key];
	                this.length--;
	                delete this.items[key];
	                return previous;
	            }
	            else {
	                return undefined;
	            }
	        }
	
	        this.keys = function()
	        {
	            var keys = [];
	            for (var k in this.items) {
	                if (this.hasItem(k)) {
	                    keys.push(k);
	                }
	            }
	            return keys;
	        }
	
	        this.values = function()
	        {
	            var values = [];
	            for (var k in this.items) {
	                if (this.hasItem(k)) {
	                    values.push(this.items[k]);
	                }
	            }
	            return values;
	        }
	
	        this.each = function(fn) {
	            for (var k in this.items) {
	                if (this.hasItem(k)) {
	                    fn(k, this.items[k]);
	                }
	            }
	        }
	
	        this.clear = function()
	        {
	            this.items = {}
	            this.length = 0;
	        }
	    }
    </script>    
 
    <script type="text/javascript">
	    function goToNewPage_pgr()
	    {
	        var url = document.getElementById('pgr-select').value;
	        if(url != 'none') {
	            window.open(url,'PANGAEA Bibliography');
	        }
	    }
	</script> 
    
    <script type="text/javascript">
	    function goToNewPage_ztr()
	    {
	        var url = document.getElementById('ztr-select').value;
	        if(url != 'none') {
	            window.open(url,'ZOTERO Bibliography');
	        }
	    }
	</script>
	
		<script>

		var slideIndex = 1;
//		showSlides(slideIndex);
		
		function plusSlides(n) {
		  showSlides(slideIndex += n);
		}
		
		function currentSlide(n) {
		  showSlides(slideIndex = n);
		}

		function showSlides(n) {
		  var i;
		  var slides = document.getElementsByClassName("mySlides");
		  var dots = document.getElementsByClassName("dot");
		  if (n > slides.length) {slideIndex = 1}    
		  if (n < 1) {slideIndex = slides.length}
		  for (i = 0; i < slides.length; i++) {
		      slides[i].style.display = "none";  
		  }
		  for (i = 0; i < dots.length; i++) {
		      dots[i].className = dots[i].className.replace(" active", "");
		  }
		  slides[slideIndex-1].style.display = "block";  
		  dots[slideIndex-1].className += " active";
		}
		
		
	</script>	

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
 
    <!-- Esri basemaps -->
    <script src="https://unpkg.com/esri-leaflet@3.0.1/dist/esri-leaflet.js"></script>
    
     <!-- EasyButton https://github.com/CliffCloud/Leaflet.EasyButton -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
	<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>

    <!-- Mapbox GL -->
    <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css" rel='stylesheet' />
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js"></script>
 
     <!-- Bootstrap for Carousel -->   
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>
    
    <!-- Bootstrap Library for Carousel -->   
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>  
	
    <!-- jQuery 2.1.1 -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
   
</head>

<body>	    
	Enter Latitude-Longitude: <input type="text" value="31.0, -78.0" name="latlong" id="latlong"/>
	<input type="button" onclick="goTo()" value="Search"/>
	<input type="button" onclick="clearMarkers()" value="Clear"/>
	<input type="button" id="howto" value="How To"/>
	<input type="button" id="about" value="About"/>  | A World Wide Compilation of Ferromanganese Oxide Deposits | NeoNodule Project Map - Version 1.4 - Published 2024-11-30

	
    <div id="sidebar">
<!--    	<h1>NeoNodule Observations</h1>
    	<p id="sidebar-text"></p> -->
    </div>
	<div id="map"></div>	
	
	<script>

	// leaflet-mapbox-gl library
	
	(function (root, factory) {
	    if (typeof define === 'function' && define.amd) {
	        // AMD
	        define(['leaflet', 'mapbox-gl'], factory);
	    } else if (typeof exports === 'object') {
	        // Node, CommonJS-like
	        module.exports = factory(require('leaflet'), require('mapbox-gl'));
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory(window.L, window.mapboxgl);
	    }
	}(this, function (L, mapboxgl) {
	    L.MapboxGL = L.Layer.extend({
	        options: {
	        updateInterval: 32
	        },

	        initialize: function (options) {
	            L.setOptions(this, options);

	            if (options.accessToken) {
	                mapboxgl.accessToken = options.accessToken;
	            } else {
	                throw new Error('You should provide a Mapbox GL access token as a token option.');
	            }

	            /**
	             * Create a version of `fn` that only fires once every `time` millseconds.
	             *
	             * @param {Function} fn the function to be throttled
	             * @param {number} time millseconds required between function calls
	             * @param {*} context the value of `this` with which the function is called
	             * @returns {Function} debounced function
	             * @private
	             */
	            var throttle = function (fn, time, context) {
	                var lock, args, wrapperFn, later;

	                later = function () {
	                    // reset lock and call if queued
	                    lock = false;
	                    if (args) {
	                        wrapperFn.apply(context, args);
	                        args = false;
	                    }
	                };

	                wrapperFn = function () {
	                    if (lock) {
	                        // called too soon, queue to call later
	                        args = arguments;

	                    } else {
	                        // call and lock until later
	                        fn.apply(context, arguments);
	                        setTimeout(later, time);
	                        lock = true;
	                    }
	                };

	                return wrapperFn;
	            };

	            // setup throttling the update event when panning
	            this._throttledUpdate = throttle(L.Util.bind(this._update, this), this.options.updateInterval);
	        },

	        onAdd: function (map) {
	            if (!this._glContainer) {
	                this._initContainer();
	            }

	            this.getPane().appendChild(this._glContainer);

	            this._initGL();

	            this._offset = this._map.containerPointToLayerPoint([0, 0]);

	            // work around https://github.com/mapbox/mapbox-gl-leaflet/issues/47
	            if (map.options.zoomAnimation) {
	                L.DomEvent.on(map._proxy, L.DomUtil.TRANSITION_END, this._transitionEnd, this);
	            }
	        },

	        onRemove: function (map) {
	            if (this._map.options.zoomAnimation) {
	                L.DomEvent.off(this._map._proxy, L.DomUtil.TRANSITION_END, this._transitionEnd, this);
	            }

	            this.getPane().removeChild(this._glContainer);
	            this._glMap.remove();
	            this._glMap = null;
	        },

	        getEvents: function () {
	            return {
	                move: this._throttledUpdate, // sensibly throttle updating while panning
	                zoomanim: this._animateZoom, // applys the zoom animation to the <canvas>
	                zoom: this._pinchZoom, // animate every zoom event for smoother pinch-zooming
	                zoomstart: this._zoomStart, // flag starting a zoom to disable panning
	                zoomend: this._zoomEnd
	            };
	        },

	        _initContainer: function () {
	            var container = this._glContainer = L.DomUtil.create('div', 'leaflet-gl-layer');

	            var size = this._map.getSize();
	            container.style.width  = size.x + 'px';
	            container.style.height = size.y + 'px';
	        },

	        _initGL: function () {
	            var center = this._map.getCenter();

	            var options = L.extend({}, this.options, {
	                container: this._glContainer,
	                interactive: false,
	                center: [center.lng, center.lat],
	                zoom: this._map.getZoom() - 1,
	                attributionControl: false
	            });

	            this._glMap = new mapboxgl.Map(options);

	            // allow GL base map to pan beyond min/max latitudes
	            this._glMap.transform.latRange = null;

	            if (this._glMap._canvas.canvas) {
	                // older versions of mapbox-gl surfaced the canvas differently
	                this._glMap._actualCanvas = this._glMap._canvas.canvas;
	            } else {
	                this._glMap._actualCanvas = this._glMap._canvas;
	            }

	            // treat child <canvas> element like L.ImageOverlay
	            L.DomUtil.addClass(this._glMap._actualCanvas, 'leaflet-image-layer');
	            L.DomUtil.addClass(this._glMap._actualCanvas, 'leaflet-zoom-animated');

	        },

	        _update: function (e) {
	            // update the offset so we can correct for it later when we zoom
	            this._offset = this._map.containerPointToLayerPoint([0, 0]);

	            if (this._zooming) {
	            return;
	            }

	            var size = this._map.getSize(),
	                container = this._glContainer,
	                gl = this._glMap,
	                topLeft = this._map.containerPointToLayerPoint([0, 0]);

	            L.DomUtil.setPosition(container, topLeft);

	            var center = this._map.getCenter();

	            // gl.setView([center.lat, center.lng], this._map.getZoom() - 1, 0);
	            // calling setView directly causes sync issues because it uses requestAnimFrame

	            var tr = gl.transform;
	            tr.center = mapboxgl.LngLat.convert([center.lng, center.lat]);
	            tr.zoom = this._map.getZoom() - 1;

	            if (gl.transform.width !== size.x || gl.transform.height !== size.y) {
	                container.style.width  = size.x + 'px';
	                container.style.height = size.y + 'px';
	                if (gl._resize !== null && gl._resize !== undefined){
	                    gl._resize();
	                } else {
	                    gl.resize();
	                }
	            } else {
	                // older versions of mapbox-gl surfaced update publicly
	                if (gl._update !== null && gl._update !== undefined){
	                    gl._update();
	                } else {
	                    gl.update();
	                }
	            }
	        },

	        // update the map constantly during a pinch zoom
	        _pinchZoom: function (e) {
	        this._glMap.jumpTo({
	            zoom: this._map.getZoom() - 1,
	            center: this._map.getCenter()
	        });
	        },

	        // borrowed from L.ImageOverlay https://github.com/Leaflet/Leaflet/blob/master/src/layer/ImageOverlay.js#L139-L144
	        _animateZoom: function (e) {
	        var scale = this._map.getZoomScale(e.zoom),
	            offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);

	        L.DomUtil.setTransform(this._glMap._actualCanvas, offset.subtract(this._offset), scale);
	        },

	        _zoomStart: function (e) {
	        this._zooming = true;
	        },

	        _zoomEnd: function () {
	        var scale = this._map.getZoomScale(this._map.getZoom()),
	            offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), this._map.getZoom(), this._map.getCenter());

	        L.DomUtil.setTransform(this._glMap._actualCanvas, offset.subtract(this._offset), scale);

	        this._zooming = false;
	        },

	        _transitionEnd: function (e) {
	        L.Util.requestAnimFrame(function () {
	            var zoom = this._map.getZoom(),
	            center = this._map.getCenter(),
	            offset = this._map.latLngToContainerPoint(this._map.getBounds().getNorthWest());

	            // reset the scale and offset
	            L.DomUtil.setTransform(this._glMap._actualCanvas, offset, 1);

	            // enable panning once the gl map is ready again
	            this._glMap.once('moveend', L.Util.bind(function () {
	                this._zoomEnd();
	            }, this));

	            // update the map position
	            this._glMap.jumpTo({
	                center: center,
	                zoom: zoom - 1
	            });
	        }, this);
	        }
	    });

	    L.mapboxGL = function (options) {
	        return new L.MapboxGL(options);
	    };

	}));

	
	
	</script>
	
	<script>
	// Leaflet-Sidebar library
	
		L.Control.Sidebar = L.Control.extend({
	
		    includes: (L.Evented.prototype || L.Mixin.Events),
	
		    options: {
		        closeButton: true,
		        position: 'left',
		        autoPan: true,
		    },
	
		    initialize: function (placeholder, options) {
		        L.setOptions(this, options);
	
		        // Find content container
		        var content = this._contentContainer = L.DomUtil.get(placeholder);
	
		        // Remove the content container from its original parent
		        content.parentNode.removeChild(content);
	
		        var l = 'leaflet-';
	
		        // Create sidebar container
		        var container = this._container =
		            L.DomUtil.create('div', l + 'sidebar ' + this.options.position);
	
		        // Style and attach content container
		        L.DomUtil.addClass(content, l + 'control');
		        container.appendChild(content);
	
		        // Create close button and attach it if configured
		        if (this.options.closeButton) {
		            var close = this._closeButton =
		                L.DomUtil.create('a', 'close', container);
		            close.innerHTML = '&times;';
		        }
		    },
	
		    addTo: function (map) {
		        var container = this._container;
		        var content = this._contentContainer;

//		        content.getElementById('ztr-select').addEventlistener('click', eventHandler_ztr, false);
//		        L.DomEvent.on(div_ztr, 'click', this.hide, this);
//		        L.DomEvent.off(div_ztr);		        
	        
		        // Attach event to close button
		        if (this.options.closeButton) {
		            var close = this._closeButton;
	
		            L.DomEvent.on(close, 'click', this.hide, this);
		        }
	
		        L.DomEvent
		            .on(container, 'transitionend',
		                this._handleTransitionEvent, this)
		            .on(container, 'webkitTransitionEnd',
		                this._handleTransitionEvent, this);
	
		        // Attach sidebar container to controls container
		        var controlContainer = map._controlContainer;
		        controlContainer.insertBefore(container, controlContainer.firstChild);
	
		        this._map = map;
	
		        // Make sure we don't drag the map when we interact with the content
		        var stop = L.DomEvent.stopPropagation;
		        var fakeStop = L.DomEvent._fakeStop || stop;
		        L.DomEvent
		            .on(content, 'contextmenu', stop)
		            .on(content, 'click', fakeStop)
		            .on(content, 'mousedown', stop)
		            .on(content, 'touchstart', stop)
		            .on(content, 'dblclick', fakeStop)
		            .on(content, 'mousewheel', stop)
		            .on(content, 'MozMousePixelScroll', stop);
	
		        return this;
		    },
	
		    removeFrom: function (map) {
		        //if the control is visible, hide it before removing it.
		        this.hide();
	
		        var container = this._container;
		        var content = this._contentContainer;
	
		        // Remove sidebar container from controls container
		        var controlContainer = map._controlContainer;
		        controlContainer.removeChild(container);
	
		        //disassociate the map object
		        this._map = null;
	
		        // Unregister events to prevent memory leak
		        var stop = L.DomEvent.stopPropagation;
		        var fakeStop = L.DomEvent._fakeStop || stop;
		        L.DomEvent
		            .off(content, 'contextmenu', stop)
		            .off(content, 'click', fakeStop)
		            .off(content, 'mousedown', stop)
		            .off(content, 'touchstart', stop)
		            .off(content, 'dblclick', fakeStop)
		            .off(content, 'mousewheel', stop)
		            .off(content, 'MozMousePixelScroll', stop);
	
		        L.DomEvent
		            .off(container, 'transitionend',
		                this._handleTransitionEvent, this)
		            .off(container, 'webkitTransitionEnd',
		                this._handleTransitionEvent, this);
	
		        if (this._closeButton && this._close) {
		            var close = this._closeButton;
	
		            L.DomEvent.off(close, 'click', this.hide, this);
		        }
	
		        return this;
		    },
	
		    isVisible: function () {
		        return L.DomUtil.hasClass(this._container, 'visible');
		    },
	
		    show: function () {
		        if (!this.isVisible()) {
		            L.DomUtil.addClass(this._container, 'visible');
		            if (this.options.autoPan) {
		                this._map.panBy([-this.getOffset() / 2, 0], {
		                    duration: 0.5
		                });
		            }
		            this.fire('show');
		        }
		    },
	
		    hide: function (e) {
		        if (this.isVisible()) {
		            L.DomUtil.removeClass(this._container, 'visible');
		            if (this.options.autoPan) {
		                this._map.panBy([this.getOffset() / 2, 0], {
		                    duration: 0.5
		                });
		            }
		            this.fire('hide');
		        }
		        if(e) {
		            L.DomEvent.stopPropagation(e);
		        }
		    },
	
		    toggle: function () {
		        if (this.isVisible()) {
		            this.hide();
		        } else {
		            this.show();
		        }
		    },
	
		    getContainer: function () {
		        return this._contentContainer;
		    },
	
		    getCloseButton: function () {
		        return this._closeButton;
		    },
	
		    setContent: function (content) {
		        var container = this.getContainer();
	
		        if (typeof content === 'string') {
		            container.innerHTML = content;
		        } else {
		            // clean current content
		            while (container.firstChild) {
		                container.removeChild(container.firstChild);
		            }
	
		            container.appendChild(content);
		        }
	
		        return this;
		    },
	
		    getOffset: function () {
		        if (this.options.position === 'right') {
		            return -this._container.offsetWidth;
		        } else {
		            return this._container.offsetWidth;
		        }
		    },
	
		    _handleTransitionEvent: function (e) {
		        if (e.propertyName == 'left' || e.propertyName == 'right')
		            this.fire(this.isVisible() ? 'shown' : 'hidden');
		    }
/*		    
	        function eventHandler_ztr() {
	          this.alert('Clicked Zotero');
	        }		    
*/		    
		});
	
		L.control.sidebar = function (placeholder, options) {
		    return new L.Control.Sidebar(placeholder, options);
		};
		
	</script>

	<script>
	
	var switch_zoom;
	var imagelayer_on;
	
		// Selected a Leaflet provider with an ocean topo map
		// See on-line list of providers: http://leaflet-extras.github.io/leaflet-providers/preview/index.html
		// Selected provider: https://korona.geog.uni-heidelberg.de/

		// Mapbox map ESRI
		
		switch_zoom = 10;
		var layer_esri_oceans = L.esri.basemapLayer('Oceans');
		var layer_esri_satellite = L.esri.basemapLayer('Imagery');

/*		
		var layer_esri_satellite = L.tileLayer('https://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}', {
			maxZoom: 19,
			attribution: 'Imagery from <a href="http://giscience.uni-hd.de/">GIScience Research Group @ University of Heidelberg</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
		});
*/
		// Mapbox map natural Earth II

		/*
//		switch_zoom = 6;
		var layer_natearth = L.tileLayer('https://a.tiles.mapbox.com/v3/mapbox.natural-earth-2/{z}/{x}/{y}.png', {
			maxZoom: 19,
			attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
		});
*/
		var my_observget_URL;
 
 		// A regular Mapbox map
		var mytilelayerz = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
			maxZoom: 19,
			attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
		});
        // Create logical flags for the baselayers
		var is_esri_oceans = false;
		var is_esri_satellite = false;
		
		var baseLayers = {
				"ESRI Oceans": layer_esri_oceans,
				"ESRI Satellite": layer_esri_satellite
			};

		// Create Leaflet map 
		var map = L.map('map', {
			center: [30.959418, -78.981916],
			zoom: 6,
		});				

//		var map = L.map('map').setView([30.959418, -78.981916], 6).addLayer(layer_natearth);
		map.addLayer(layer_esri_oceans);
		var mylayercontrol = L.control.layers(baseLayers,null,{collapsed:false});
		var lc = document.getElementsByClassName('leaflet-control-layers');
		mylayercontrol.addTo(map);		

		// Create sidebar 		
        var sidebar = L.control.sidebar('sidebar', {
            closeButton: true,
            position: 'right'
        });
        map.addControl(sidebar);
        
        // Create array of markers resulting from user search
		var markersarray = new Array();
		
		map.on('moveend', function () {
		    if (map.getZoom() > switch_zoom && map.hasLayer(layer_esri_oceans)) {
		    	layer_esri_oceans.removeFrom(map);
		    	is_esri_oceans = true;
		    	lc[0].style.visibility = 'hidden';
		       	mytilelayerz.addTo(map);
		    } 
		    if (map.getZoom() > switch_zoom && map.hasLayer(layer_esri_satellite)) {
		    	layer_esri_satellite.removeFrom(map);
		    	is_esri_satellite = true;
		    	lc[0].style.visibility = 'hidden';
		       	mytilelayerz.addTo(map);
		    } 
	    	if (map.getZoom() <= switch_zoom && map.hasLayer(mytilelayerz)){
			   	mytilelayerz.removeFrom(map);
			    if(is_esri_oceans){layer_esri_oceans.addTo(map);}
			    if(is_esri_satellite){layer_esri_satellite.addTo(map);}
				is_esri_oceans = false; is_esri_satellite = false;
			    lc[0].style.visibility = 'visible';			       		    		
	    	}
		})		

		function goTo() {
			var array;
			try{
				array = JSON.parse("[" + document.getElementById("latlong").value + "]");
				if(array.length == 2){
				  	var newmarker = new L.marker([array[0], array[1]], {
					    draggable: true,
					    title: "Resource location",
					    alt: "Resource Location",
					    riseOnHover: true
				  	});
				  markersarray.push(newmarker);
				  map.addLayer(markersarray[markersarray.length - 1]);
				  map.panTo(new L.LatLng(array[0], array[1]));	
				} else {
					alert('Please submit coordinates as: lat,long'+'\n'
							+'  comma separated and in decimal degrees');									
				}
			}
			catch(e){
				alert('Please submit coordinates as: lat,long'+'\n'
						+'  comma separated and in decimal degrees');				
			}
		}

		function clearMarkers() {
			for(i=0; i<markersarray.length; i++) {
			    map.removeLayer(markersarray[i]);
			    }		
		}
		
		function onEachFeature(feature, layer) {
			var popupContent = "";
	        var props = feature.properties,
	        attrs = Object.keys(props),
	        attribute, value;
			
			for (var i = 0; i < attrs.length; i += 1) {
			    attribute = attrs[i];
			    value = props[attribute];
			    popupContent += '<b>'+attribute+': '+'</b>'+value+'<br />';
			}		
			
			layer.bindPopup(popupContent);
		}
		
//		var my_mapbox_eventmapid = 'geointelligent.dzraks3d'; // MapBox Tileset MapID: NeoNodule_Events_2024-02-06-5rq283
		var my_mapbox_eventmapid = 'geointelligent.3sabzon2'; // MapBox Tileset MapID: NeoNodule_Events_2024-11-30-0csw7k

//		var my_mapbox_observmapid_all = 'geointelligent.4m4f8p47'; // MapBox Tileset MapID: NeoNodule_Observations_2024-0-4j38bk
		var my_mapbox_observmapid_all = 'geointelligent.br63qcp7'; // MapBox Tileset MapID: NeoNodule_Observations_2024-1-1yn4t1

//		var my_mapbox_observmapid_images = 'geointelligent.1494a0w2'; // MapBox Tileset MapID: NeoNodule_Images_2024-02-06-0I7oay
//		var my_mapbox_observmapid_coating = 'geointelligent.3rvy8z4b'; // MapBox Tileset MapID: NeoNodule_Coating_2024-02-06-834qsx	
//		var my_mapbox_observmapid_crust = 'geointelligent.4y7g1axk'; // MapBox Tileset MapID:  NeoNodule_Crust_2024-02-06-7p02c4		
//		var my_mapbox_observmapid_nodule = 'geointelligent.28t1vw3m'; // MapBox Tileset MapID: NeoNodule_Nodule_2024-02-06-534wje
//		var my_mapbox_observmapid_micronodule = 'geointelligent.1vpf5z5m'; // MapBox Tileset MapID: NeoNodule_Micronodule_2024-11-c0iqkt
//		var my_mapbox_observmapid_p2o5 = 'geointelligent.6db5pt1f'; // MapBox Tileset MapID: NeoNodule_P2O5_2024-02-06-7ho2o6		
//		var my_mapbox_observmapid_layerrich = 'geointelligent.daellsig'; // MapBox Tileset MapID: NeoNodule_LayerRich_2024-11-3-55o3ot
		var my_mapbox_observmapid_images = 'geointelligent.651ti626'; // MapBox Tileset MapID: NeoNodule_Images_2024-11-30-5lpc4m
		var my_mapbox_observmapid_coating = 'geointelligent.31g9cpiw'; // MapBox Tileset MapID: NeoNodule_Coating_2024-11-30-8f6khe
		var my_mapbox_observmapid_crust = 'geointelligent.14m941jv'; // MapBox Tileset MapID:  NeoNodule_Crust_2024-11-30_-6ds257		
		var my_mapbox_observmapid_nodule = 'geointelligent.8dla8jsa'; // MapBox Tileset MapID: NeoNodule_Nodule_2024-11-30-1h1tt0
		var my_mapbox_observmapid_micronodule = 'geointelligent.2wz1t40o'; // MapBox Tileset MapID: NeoNodule_Micronodule_2024-11-550s
		var my_mapbox_observmapid_p2o5 = 'geointelligent.a3kegaw2'; // MapBox Tileset MapID: NeoNodule_P2O5_2024-11-30-2ekhws		
		var my_mapbox_observmapid_layerrich = 'geointelligent.8wxcev3o'; // MapBox Tileset MapID: NeoNodule_LayerRich_2024-11-3-3pqwr5

		var my_mapbox_observmapid_pangaea = 'ggeointelligent.6ixc95be'; // MapBox Tileset MapID: NeoNodule_PANGAEA_2024-11-30-d4tas1
		var my_mapbox_observmapid_neonod = 'geointelligent.1laugd70'; // MapBox Tileset MapID: NeoNodule_NEONOD_2024-11-30-1lysvv
		var my_mapbox_observmapid_noaa = 'geointelligent.5wm0j3z8'; // MapBox Tileset MapID: NeoNodule_NOAA_2024-11-30-cii5ix



		var my_mapbox_accesstoken = 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ';
		
		var eventgl = L.mapboxGL({ 
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clshjw6pv00e001pf5ol4g7st'		// MapBox Style: neonodule_events_2024-02-06
			style: 'mapbox://styles/geointelligent/cm44h47ol00a101sa5l886dr8'		// MapBox Style: neonodule_events_2024-11-30
		}).addTo(map);
		
		var imageeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf5o9u6x004x01lnhu8jezi0'	// NeoNodule_Images_2024-02-06-0I7oay
			style: 'mapbox://styles/geointelligent/cm44hrxt0011f01sd42g4e3s4'	// NeoNodule_Images_2024-11-30
		}).addTo(map);
		
		var coatingeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf6pjdyn00a001qkddzoir68'	// MapBox Style: neonodule_coating_2024-02-06
			style: 'mapbox://styles/geointelligent/cm45096jd011r01r23lnf4okl'	// MapBox Style: neonodule_coating_2024-11-30

		}).addTo(map);
		
		var crusteventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf6q89xq00au01peuqvd8cig'	// MapBox Style: neonodule_crust_2024-02-06	
			style: 'mapbox://styles/geointelligent/cm45i2b0d00zv01sdayko0pi3'	// MapBox Style: neonodule_crust_2024-11-30	

		}).addTo(map);
		
		var noduleeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf6qj0h000av01pejw59fn9k'	// MapBox Style: neonodule_nodule_2024-02-06
			style: 'mapbox://styles/geointelligent/cm45hz8qt012d01s8c5b0dohi'	// MapBox Style: neonodule_nodule_2024-11-30

		}).addTo(map);

		var micronoduleeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf6qktp4008401pg82yuibax'	// MapBox Style: neonodule_micronodule_2024-02-06
			style: 'mapbox://styles/geointelligent/cm45i9aof012301r231eqfrrw'	// MapBox Style: neonodule_micronodule_2024-11-30
		}).addTo(map);
		
		var p2o5eventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf6qmezo008a01nhn9vy5wyd'	// MapBox Style: neonodule_p2O5_2024-02-06
			style: 'mapbox://styles/geointelligent/cm45ic7tf00zy01sdgs5i8d9g'	// MapBox Style: neonodule_p2o5_2022-11-30
		}).addTo(map);

		var layerricheventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
//			style: 'mapbox://styles/geointelligent/clf6qnxc9006901lnilfnv07l'	// MapBox Style: neonodule_layerrich_2024-02-06
			style: 'mapbox://styles/geointelligent/cm45igbyx000x01s4egeecbxo'	// MapBox Style: neonodule_layerrich_2024-11-30
		}).addTo(map);

		var pangaeaeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
			style: 'mapbox://styles/geointelligent/cm45il9sw000y01s4ds0g7p6r'	// MapBox Style: neonodule_pangaea_2024-11-30
		}).addTo(map);

		var neonodeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
			style: 'mapbox://styles/geointelligent/cm45in9uy008y01r1gakge7rd'	// MapBox Style: neonodule_neonod_2024-11-30
		}).addTo(map);

		var noaaeventgl = L.mapboxGL({
		    accessToken: 'pk.eyJ1IjoiZ2VvaW50ZWxsaWdlbnQiLCJhIjoiY2prODh4YngyMWk0YzNwbzRyZWI0amFiZiJ9.I3lwpb6UxH9WfCo71ZNBGQ',
			style: 'mapbox://styles/geointelligent/cm45ioxzf012y01sic64bg3ck'	// MapBox Style: neonodule_noaa_2024-11-30
		}).addTo(map);
		
		var eventpopup = L.popup();
//		mylayercontrol.addOverlay(eventgl, "All");
//		mylayercontrol.addOverlay(oldeventgl, "Old");
		var event_selected = "";

		var dataLayers = {
				"PANGAEA": pangaeaeventgl,
				"NEONOD": neonodeventgl,
				"NOAA": noaaeventgl,
				"Images": imageeventgl,
				"Rich layer": layerricheventgl,
				"Micronodule": micronoduleeventgl,
				"P2O5-Mn": p2o5eventgl,
				"Coating+Staining": coatingeventgl,
				"Crust": crusteventgl,
				"Nodule": noduleeventgl,
				"All": eventgl
		};
		var mylayercontrol2 = L.control.layers(dataLayers,null,{collapsed:false});
		mylayercontrol2.addTo(map);		
		imagelayer_on = "All";

		function onMapClick(e) {

				sidebar.hide();

				var latlng_wrap;

				var eventpopupContent_empty = "";
				var eventpopupContent_waiting = "";
				var eventpopupContent = "";

				var observJSON;
				var observSize;
				var observrank;
				var observbuttonContent = "";
		        var observbuttonDeposit = "";
		        var observbuttonDepth = "";
		        
		        var h_eventpop = new HashTable();
		        var eventlabels = [
		        	'Event', 'OptionalLabelEvent', 'Campaign', 'Basis', 'Area', 'Device', 'DateTimeEvent',
		        	'Latitude', 'Longitude', 'Elevation [m]', 'Altitude', 'Cored [m]', 'Recovered [kg]',
		        	'Penetration [m]', 'PI', 'Institute', 'Comment', 'Event_Image_link', 'URL page' 
		       		 ];
				
				latlng_wrap = e.latlng.wrap();
//		        alert(latlng_wrap.lat.toString()+" : "+latlng_wrap.lng.toString());

			// Create a deferred object
				var dfd = $.Deferred();
			
				// First call the event layer in order to fill eventpopupContent
				
				var my_eventget_URL = "https://api.mapbox.com/v4/"+my_mapbox_eventmapid+"/tilequery/"+latlng_wrap.lng.toString()+","+latlng_wrap.lat.toString()+".json?radius=10000&access_token="+my_mapbox_accesstoken;

				dfd = $.ajax({
				    type: 'GET',
				    url: my_eventget_URL,
				    dataType : 'json',
				    success: function (response) {
					    if (response.features.length > 0) {
							event_selected = "";
				            					        
					        var feature = response.features[0];		    // Only one feature extracted
						    var props = feature.properties;
						    var attrs = Object.keys(props);
					        var attribute, value;

							eventpopupContent += '<b>  --- STATION INFORMATION ---</b><br />';
							for (var i = 0; i < attrs.length; i += 1) {
							    attribute = attrs[i];
							    value = props[attribute];
							    							    							    
							    if(attribute == "Event_Image_link"){ 
						    		if(!(value == "")){
										var imevlink = value;
										var image_eventlinks = imevlink.split(',');
								    	// At this point we only retain the first image in the list
								    	//   TBD - Have an album window of multiple images
								    	h_eventpop.setItem('Event_Image_link', 
								    			'<div><img style="width:100%" src="'+image_eventlinks[0]+'" alt="image"/></div>')
						    		}
							    } else {
								    if(attribute == "URL page"){ 
							    		if(!(value == "")){
											var imurllink = value;
											var image_urllinks = imurllink.split(',');
									    	// At this point we only retain the first image in the list
									    	//   TBD - Have an album window of multiple images
									    	h_eventpop.setItem('URL page', 
									    			'<b><a target="_blank" href="'+image_urllinks[0]+'">Link to full core info</a></b><br />')
							    		}
								    } else {
								    	if(!(attribute == "tilequery")){
								    		if(!(value == "")){
								    			switch(attribute){
								    			 // Next attributes are ignored
								    			 case "PGEventID":
								    				 break;
								    			 case "NeoNoduleEventID":
								    				 break;
								    			 case "Event":
								    				 	event_selected = value;
												    	h_eventpop.setItem(attribute, 
												    			'<b>Station (event): '+'</b>'+value+'<br />')
											    	 break;
								    			 default:
											    	h_eventpop.setItem(attribute, 
											    			'<b>'+attribute+': '+'</b>'+value+'<br />')
								    			}								    		 							    			
								    		}
								    	}								    
								    }

							    }
							}							

							eventpopupContent = '<b>  --- STATION INFORMATION ---</b><br />';
							for (var ii = 0; ii < eventlabels.length; ii += 1) {
								if(!(h_eventpop.getItem(eventlabels[ii]) === undefined )){
									eventpopupContent += h_eventpop.getItem(eventlabels[ii]);
								}
							}
							
							eventpopupContent += '<b>  --- OBSERVATIONS MADE ---</b><br />';							
							
							eventpopupContent_empty = eventpopupContent;
							eventpopupContent_waiting = eventpopupContent+'Waiting for more ...<br />';
					    	if(!(observbuttonContent == "")){ 
					    		eventpopupContent = eventpopupContent+observbuttonContent;
								eventpopup
								.setLatLng(e.latlng)
								.setContent(eventpopupContent)
								.openOn(map);					    
					    	} else { // Message waiting only if observbuttonContent is empty
								eventpopup
								.setLatLng(e.latlng)
								.setContent(eventpopupContent_waiting)
								.openOn(map);					    					    		
					    	}					    
					    }
				    },
				    error: function (req, status, error) {
				        alert('what happened ?');
				    }
				});

				dfd.done(function(n) { // In order to maintain defered call sequence. Does it work ??
				});
				
				// Second call the observation layer in order to fill observation JSON content
				my_observget_URL = "https://api.mapbox.com/v4/"+my_mapbox_observmapid_all+"/tilequery/"+latlng_wrap.lng.toString()+","+latlng_wrap.lat.toString()+".json?radius=10000&access_token="+my_mapbox_accesstoken;
				
//				switch(imagelayer_on){

				
				$.ajax({
				    type: 'GET',
				    url: my_observget_URL,
				    dataType : 'json',
				    success: function (response) {
				    	observSize = response.features.length;
//				        alert(observSize);
					    if (observSize > 0) {

					    	for (ii = 0; ii < observSize; ii += 1) {

						        observbuttonDeposit = "";
						        observbuttonDepth = "";
					    		
					    		var feature = response.features[ii];		    // Only one feature extracted
							    var props = feature.properties;
							    var attrs = Object.keys(props);
						        var attribute, value;
								
								for (var j = 0; j < attrs.length; j += 1) {
								    attribute = attrs[j];
								    value = props[attribute];
								    
							    	if(!(attribute == "tilequery")){
							    		if(!(value == "")){
							    			switch(attribute){
							    			// Attributes needed for pointing buttons in the event popup
							    			 case "Deposit type":
							    				 observbuttonDeposit = value+" ";
							    				 break;
							    			 case "Depth [m]":
							    				 observbuttonDepth = value+" ";
							    				 break;
							    			 default:
							    			}
							    		}
							    	}
								    
								}
					    		observrank = ii + 1;
					    		observbuttonContent += '<b>Depth: </b>'+observbuttonDepth+'<b> - Type: </b>'+observbuttonDeposit;
					    		observJSON = JSON.stringify(feature);
//						        alert(observJSON);

								// Forced to use uni-quotes because of double-quotes in JSON format
					    		observbuttonContent += "</b><button type='button' class='alt-open-button' val='"+observJSON+"'> View more ...</button><br />";
					    		// Re-init for next observation
					    	}
				           
					    	if(!(eventpopupContent == "")){ // Update only if content is not blank
					    		eventpopupContent = eventpopupContent+observbuttonContent;
							    eventpopup.setContent(eventpopupContent);
							    eventpopup.update;
					    	}

					    } else { // Nothing to add to the popup
					    	if(!(eventpopupContent == "")){ // Update only if content is not blank
							    eventpopup.setContent(eventpopupContent_empty);
							    eventpopup.update;					    	
					    	}
					    }
					    
				    },
				    error: function (req, status, error) {
				        alert('what happened ?');
				    }
				});	
				
		}
		
		map.on('click', onMapClick);

        $("div").on("click", '.alt-open-button', function (e) {
        	// Avoids multiple display of alert
        	e.stopImmediatePropagation();
//        	alert("clicked");
			var observtext = $(this).attr("val");
    		var feature = JSON.parse(observtext);		    // Only one feature extracted
		    var props = feature.properties;
		    var attrs = Object.keys(props);
	        var attribute, value;

	        var h_obspop = new HashTable();
	        var observlabels = [
	        	'Event', 'Latitude', 'Longitude', 'Elevation [m]', 'Device', 'ObsID',
	        	'Depth [m]', 'Depth top [m]', 'Depth bot [m]', 'Position', 'Deposit type',
	        	'Quantity', 'Size', 'Substrate', 'Sediment', 'PANGAEA_links', 'ZOTERO_links', 'Obs_Image_link', 'Comment', 'Description'	       		 
	        	];	        
	        var observpopupContent = "";
			
			for (var j = 0; j < attrs.length; j += 1) {
			    attribute = attrs[j];
			    value = props[attribute];
			    
			    if(attribute == "Obs_Image_link"){ 
		    		if( !(value == "") ){
		    			var imlink = value;
		    			if( !(imlink.indexOf('TBD') >= 0) ){	
		    				var imagelinks = imlink.split(',');
		    				observpopupContent = '';
							// Adding the image slideshow
							observpopupContent += '<div class="slideshow-container">';
							for (var jj = 0; jj < imagelinks.length; jj += 1) {
								var j1 = jj + 1;
								observpopupContent += '<div class="mySlides">';
								observpopupContent += '<div class="numbertext">'+j1+' / '+imagelinks.length+'</div>';
								observpopupContent += '<div><a target="_blank" href="'+imagelinks[jj]+'"><img style="width:100%" src="'+imagelinks[jj]+'" alt="image"/></a></div>';
								observpopupContent += '</div>';								
							}
							observpopupContent += '<a class="prev" onclick="plusSlides(-1)">&#10094;</a>';
							observpopupContent += '<a class="next" onclick="plusSlides(1)">&#10095;</a>';
							observpopupContent += '</div><br>';
							
							observpopupContent += '<div style="text-align:center">';
							for (var jj = 0; jj < imagelinks.length; jj += 1) {
								var j1 = jj + 1;
								observpopupContent += '<span class="dot" onclick="currentSlide('+j1+')"></span>';
							}
							observpopupContent += '</div>';
					    	h_obspop.setItem('Obs_Image_link' , observpopupContent);
					    	
		    			}
		    		}
			    } else {
			    	if(!(attribute == "tilequery")){
			    		if(!(value == "")){
			    			switch(attribute){
			    			 case "PANGAEA_links":

					    			 var pangaealinks = value.toString().split(',');			    				 
									 observpopupContent = '';
									 observpopupContent += '<label for="pgr-selection">Data on PANGAEA > (Select in list below)</label>';
									 observpopupContent += '<form><select id="pgr-select">';
									 for (var jj = 0; jj < pangaealinks.length; jj += 1) {
										 observpopupContent += '<option value="'+'https://doi.pangaea.de/10.1594/PANGAEA.'+pangaealinks[jj]+'">'+pangaealinks[jj]+'</option>';
									 }
									 observpopupContent += '</select><input type=button value="Go" onclick="goToNewPage_pgr()" /></form>';											 
								     h_obspop.setItem('PANGAEA_links', observpopupContent);

/*
									var pangaealinks = value.toString().split(',');	
									if (pangaealinks.length > 0){
													
										 observpopupContent = '';
										 observpopupContent += '<b><a target="_blank" href=https://doi.pangaea.de/10.1594/PANGAEA.'+pangaealinks[0]+'>Go to PANGAEA data...</a></b><br />';
										 h_obspop.setItem('PANGAEA_links', observpopupContent);
																											
									}
*/
									 break;
			    			 case "ZOTERO_links":
					    			 var zoterolinks = value.toString().split(',');			    				 
//				    				 var ztrlink = "https://www.zotero.org/mariotv/items/"+zoterolinks[0];
									 observpopupContent = '';
									 observpopupContent += '<label for="ztr-selection">References on ZOTERO > (Select in list below)</label>';
									 observpopupContent += '<form><select id="ztr-select">';
									 for (var jj = 0; jj < zoterolinks.length; jj += 1) {
										 observpopupContent += '<option value="'+'https://www.zotero.org/mariotv/items/'+zoterolinks[jj]+'">'+zoterolinks[jj]+'</option>';
									 }
									 observpopupContent += '</select><input type=button value="Go" onclick="goToNewPage_ztr()" /></form>';											 
								     h_obspop.setItem('ZOTERO_links', observpopupContent);
			    				 break;
			    			 case "Event":
			    				 observpopupContent = '';
			    				 observpopupContent += '<b>Station (event): '+'</b>'+value+'<br />';
						         h_obspop.setItem(attribute, observpopupContent);
						    	 break;
			    			 // Next attributes are ignored
			    			 case "Pflag":
			    				 break;
			    			 case "PGEventID":
			    				 break;
			    			 case "NNEventID":
			    				 break;
			    			 case "Type_code":
			    				 break;
			    			 case "Has_image":
			    				 break;
			    			 case "Image_File":
			    				 break;
			    			 case "Alternate_Image_link":
			    				 break;
			    			 default:
			    				 observpopupContent = '';
			    				 observpopupContent += '<b>'+attribute+': '+'</b>'+value+'<br />';
						         h_obspop.setItem(attribute, observpopupContent);
			    			}
			    		}
			    	}
			    }
			}			
	
			observpopupContent = '<h2>NeoNodule Observations</h2>';
			for (var ii = 0; ii < observlabels.length; ii += 1) {
				if(!(h_obspop.getItem(observlabels[ii]) === undefined )){
					observpopupContent += h_obspop.getItem(observlabels[ii]);
				}
			}
			
			sidebar.setContent(observpopupContent);
        	sidebar.toggle();
    		slideIndex = 1;
    		showSlides(slideIndex);
        }); // End $("div").on("click" - Observ sidebar

        map.on('baselayerchange', function (e) {
//            console.log(e.name); // The name of the layer that was added or removed.
//            console.log(e.layer); // The layer that was added or removed.
//        	alert('Layers selected: ' + e.name);
            fired_layer = e.name;
            switch(fired_layer){
           // BaseMap layers
			 case "ESRI Oceans": 
					switch_zoom = 10;
				    if (map.getZoom() > switch_zoom && map.hasLayer(layer_esri_oceans)) {
				    	layer_esri_oceans.removeFrom(map);
				    	is_esri_oceans = true; is_esri_satellite = false;
				    	lc[0].style.visibility = 'hidden';
				       	map.addLayer(mytilelayerz);
				    } 
				 break;
			 case "ESRI Satellite":
					switch_zoom = 20;
				    if (map.getZoom() > switch_zoom && map.hasLayer(layer_esri_satellite)) {
				    	layer_esri_satellite.removeFrom(map);
				    	is_esri_oceans = true; is_esri_satellite = false;
				    	lc[0].style.visibility = 'hidden';
				       	map.addLayer(mytilelayerz);
				    } 
				 break;
           
            // Datalayers
			 case "All": 
				 imagelayer_on = "All";
				 e.layer.redraw();
				 break;
			 case "Images": 
				 imagelayer_on = "Images";
				 e.layer.redraw();
				 break;
			 case "Nodule": 
				 imagelayer_on = "Nodule";
				 e.layer.redraw();
				 break;
			 case "Crust": 
				 imagelayer_on = "Crust";
				 e.layer.redraw();
				 break;
			 case "Coating+Staining": 
				 imagelayer_on = "Coating+Staining";
				 e.layer.redraw();
				 break;
			 case "P2O5-Mn": 
				 imagelayer_on = "P205-Mn";
				 e.layer.redraw();
				 break;
			 case "Micronodule": 
				 imagelayer_on = "Micronodule";
				 e.layer.redraw();
				 break;
			 case "Rich layer": 
				 imagelayer_on = "Rich layer";
				 e.layer.redraw();
				 break;           
            }
       }); 
        
        // Info popups
    	var about_popup;
    	var howto_popup;
    	
        map.on('popupclose', function (e) {
        	 if(!(about_popup == null)){ about_popup = null;}
        	 if(!(howto_popup == null)){ howto_popup = null;}
        });
        
        
        $( "#howto" ).click(function() {
//    	    alert('clicked! a');
    		if(howto_popup == null){
           		howto_popup = L.popup()
        	    	.setLatLng(map.getCenter())
        	    	.setContent(
       	    			'<h3>The NeoNodule data project</h3>'
       	    			+'<p><strong>How to use this map :</strong><br /> -&gt; <strong>Scroll</strong>: either by dragging the mouse or by using the keyboard arrows<br />'
       	    			+' -&gt; <strong>Zoom</strong>: use the mouse wheel or the +/- options of the widget in left-upper corner<br /> -&gt; <strong>'
       	    			+'Get information on station</strong>: double left-click with mouse on point in order to get the station (event) Information Window.<br />'
       	    			+' -&gt; <strong>Get an Observation Panel from an Information Window</strong>: Ounce the information window is opened, a list of observed deposits follows the station info.'
       	    			+' Scroll window if necessary in order to see all of them.<br /> Click on "View More" button in order to open the Observation Panel which appears on the right side.<br />'
       	    			+' -&gt;' +'<strong>Access PANGAEA</strong> data repository, <strong>ZOTERO</strong> bibliography<br /> -&gt;'
       	    			+'<strong>Display full-view image</strong> by double-clicking on it. <strong>Switch between multiple images</strong> using the bottom light grey bullet<br /> -&gt;'
       	    			+' To <strong>close an Observation Panel</strong> either: double-click outside of the panel or click on the corresponding button inside the Information Window<br /> -&gt;' +'<strong>Search for deposits</strong> by Lat/long using the "Search" button in the top menu</p>'        	    		
       	    			+'<p>-&gt; <strong>Change background map</strong>: using the upper right bullet list. The ESRI Oceans map is the best background but it is sometimes resources demanding.'
       	    			+' While zooming to a local spot, the background is switched to the OpenStreetMap background when the others are not available at that level of details.<br />'
       	    			+'The program uses both the <strong><a href="https://leafletjs.com/">Leaflet</a></strong>&nbsp;and<strong> <a href="https://www.mapbox.com/">MapBox</a>'
       	    			+'</strong>&nbsp;javascript libraries along with <strong><a href="https://jquery.com/">JQuery</a></strong> and other compatible libraries</p>'
       	    			+'<h3>Important feature (glitch!)</h3>'
       	    			+'<p>When swiching thematic layers it may be necessary to <strong>slightly "DRAG THE MAP WITH THE MOUSE"</strong> in order to reposition correctly the data layer.</p>'
       	    			+'<p>For more information on the project visit the&nbsp; <a href="https://www.researchgate.net/publication/274310203_The_NeoNodule_Project_-_A_Summary">'
       	    			+'ResearchGate site</a>. Download here the <a href="https://www.researchgate.net/profile/Jean-Marie-Monget/publication/336851955_NeoNodule_Project_DataBase_-_Compilation_table_of_world-wide_stations_where_ferromanganese_oxide_deposits_are_located/data/60d0aea4a6fdcc01d48e1cda/NeoNodule-RS-Events-2021-05-25.csv">'
       	    			+'station (event) data</a> &nbsp;'
       	    			+'and the <a href="https://www.researchgate.net/profile/Jean-Marie-Monget/publication/336852070_NeoNodule_Project_DataBase_-_Compilation_table_of_world-wide_descriptions_of_ferromanganese_oxide_deposits/data/60d0bb85a6fdcc01d48e21fe/NeoNodule-RS-Observations-2021-25-05.csv">observation data</a>'
       	    			+'&nbsp; </p>'
        	    	)
        	    	.openOn(map);    	   			
    		} else {
    			map.closePopup();
    			howto_popup = null;
    		}
    	});
    	$("#about").click(function(){
    		if(about_popup == null){
           		about_popup = L.popup()
        	    	.setLatLng(map.getCenter())
        	    	.setContent(
        	    		'<h3>The NeoNodule data project</h3>'
        	    		+'<p>Cite as:&nbsp;<strong>Jean-Marie Monget (2015):&nbsp;<em>The NeoNodule Project - A Summary</em>. ResearchGate, 5 pp.&nbsp;</strong><strong><a href="http://dx.doi.org/10.13140/RG.2.1.2297.0403">doi:10.13140/RG.2.1.2297.0403</a></strong></p>'
        	    		+'<p>The project aims at curating the data and information published about hydrogeneous manganese deposits since the concept was originated by Carl Wilhelm Von Gumbel in 1861 '
        	    		+'and marine manganese nodules where recovered during the Challenger Expedition of 1872-76 and further analysed by John Murray and his associates. '
        	    		+'It stems from the past compiling efforts of the <a title="NOAA-NGDC" href="https://wiki.pangaea.de/wiki/NOAA-MMS">NOAA-NGDC Marine Minerals Data Base</a>.</p>'
        	    		+'<p>The first phase of its development has consisted in the encoding of data published in the literature into the <a title="PANGAEA" href="https://www.pangaea.de/">PANGAEA data base</a> '
        	    		+'managed by the Alfred Wegener Institute, Bremen. The geochemical and descriptive data has been stored under the '
        	    		+'<a title="NOAA-MMS" href="https://www.pangaea.de/?q=NOAA-MMS">NOAAA-MMS project denomination</a>. ' 
        	    		+'It is complemented by an&nbsp;<a href="https://www.zotero.org/mariotv/items">open on-line extensive bibliography.</a>&nbsp;The present&nbsp;click-on geographic map'
        	    		+' of locations where manganese nodules and crusts have been identified and studied has been recently added to the project.</p>'
        	    		+'<p>The author&nbsp;gratefully acknowledges the invaluable help he received from his colleagues. In particular, Carla Moore from NOAA National Centers for Environmental Information'
        	    		+' (NCEI), Boulder, Colorado as well as Hannes Grobe and Amelie Driemel from the PANGEA team,&nbsp;Alfred Wegener Institute, Bremen.</p>'        	    		
        	    	)
        	    	.openOn(map);    	   			
    		} else {
    			map.closePopup();
    			about_popup = null;
    		}
    	});    	 	
    	
    	$(document).ready(function() {
    		about_popup = null;
    		howto_popup = null;
    	});      

	</script>
</body>
</html>